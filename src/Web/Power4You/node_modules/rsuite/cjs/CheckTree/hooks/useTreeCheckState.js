'use client';
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _react = require("react");
var _isNil = _interopRequireDefault(require("lodash/isNil"));
var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));
var _hooks = require("../../internals/hooks");
var _TreeProvider = require("../../internals/Tree/TreeProvider");
var _utils = require("../utils");
function useTreeCheckState(props) {
  const {
    cascade,
    flattenedNodes,
    uncheckableItemValues
  } = props;
  const {
    valueKey,
    childrenKey
  } = (0, _TreeProvider.useItemDataKeys)();
  const checkParentNode = (0, _hooks.useEventCallback)((nodes, node, checked) => {
    const currentNode = node.refKey ? nodes[node.refKey] : null;
    if (cascade && currentNode) {
      if (!checked) {
        currentNode.check = checked;
        currentNode.checkAll = checked;
      } else {
        if ((0, _utils.isEveryChildChecked)(currentNode, {
          nodes,
          childrenKey
        })) {
          currentNode.check = true;
          currentNode.checkAll = true;
        } else {
          currentNode.check = false;
          currentNode.checkAll = false;
        }
      }
      if (currentNode.parent) {
        checkParentNode(nodes, currentNode.parent, checked);
      }
    }
  });
  const checkChildNode = (0, _hooks.useEventCallback)((nodes, node, isChecked) => {
    const currentNode = node.refKey ? nodes[node.refKey] : null;
    if (!currentNode) {
      return;
    }
    currentNode.check = isChecked;
    if (!currentNode[childrenKey] || !currentNode[childrenKey].length || !cascade) {
      currentNode.checkAll = false;
    } else {
      currentNode.checkAll = isChecked;
      currentNode[childrenKey].forEach(child => {
        checkChildNode(nodes, child, isChecked);
      });
    }
  });
  const getCheckedValuesByParent = (0, _react.useCallback)(nodes => {
    const values = [];
    for (const key in nodes) {
      const currentNode = nodes[key];
      if (!(0, _isNil.default)(currentNode.parent) && !(0, _isNil.default)(currentNode.parent.refKey)) {
        const parentNode = nodes[currentNode.parent.refKey];
        if (currentNode.check) {
          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {
            values.push(currentNode[valueKey]);
          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {
            values.push(currentNode[valueKey]);
          }
        }
      } else if (currentNode.check) {
        values.push(currentNode[valueKey]);
      }
    }
    return values;
  }, [valueKey]);
  const getCheckedValues = (0, _hooks.useEventCallback)((node, isChecked) => {
    const nodes = (0, _cloneDeep.default)(flattenedNodes);
    checkChildNode(nodes, node, isChecked);
    if (node.parent) {
      checkParentNode(nodes, node.parent, isChecked);
    }
    const values = getCheckedValuesByParent(nodes);
    return values.filter(v => !uncheckableItemValues.includes(v));
  });
  return {
    getCheckedValues
  };
}
var _default = exports.default = useTreeCheckState;